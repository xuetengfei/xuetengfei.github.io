# 浏览器怎么进行垃圾回收？

## 变量的生命周期

```javascript
let dog = {};
dog.a = [];
```

<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-jLBcSD-GC-1.png' width='600px'/>

```javascript
let dog = {};
// dog.a = [];
dog.a = {};
```

<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-IHbHaF-GC-2.png' width='600px'/>

a 的指向改变了， 此时堆中的数组对象就成为了不被使用的数据，专业名词叫「不可达」
的数据。这就是需要回收的垃圾数据。

## 什么时候垃圾回收

浏览器进行垃圾回收的时候，会暂停 JavaScript 脚本，等垃圾回收完毕再继续执行。

对于普通应用这样没什么问题，但对于 JS 游戏、动画对连贯性要求比较高的应用，如果暂
停时间很长就会造成页面卡顿。

垃圾收集器只会在 CPU 空闲时见缝插针式的尝试运行，以减少可能对代码执行的影响。

## 临时对象 VS 长久对象

<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-N3xGwV-GC-3.png' width='600px'/>

浏览器将数据分为两种，一种是「临时」对象，一种是「长久」对象。

| 对象     | 存活的时间 |                                  对象                                  |
| :------- | :--------- | :--------------------------------------------------------------------: |
| 临时对象 | 短         | 函数内部、块级作用域中的变量。执行结束时，作用域中定义的变量就会被销毁 |
| 长久对象 | 长         |                      全局的 window、DOM、Web API                       |

这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域

| 对象     | V8 堆区分 | 回收器       | 算法                     | 碎片整理 |
| -------- | --------- | ------------ | ------------------------ | -------- |
| 临时对象 | 新生代    | 副垃圾回收器 | 对象、空闲区域，复制对调 | 不需要   |
| 长久对象 | 老生代    | 主垃圾回收器 | 标记-清除                | 需要     |

## 主垃圾回收器

负责老生代的垃圾回收，老生代有两个特点：对象占用空间大；对象存活时间长。  
它使用「标记-清除」的算法执行垃圾回收。

首先是标记。从一组根元素开始，递归遍历这组根元素；在这个遍历过程中，能到达的元素
称为活动对象，没有到达的元素就可以判断为垃圾数据。然后是垃圾清除。

直接将标记为垃圾的数据清理掉。多次标记-清除后，会产生大量不连续的内存碎片，需要
进行内存整理。

## 副垃圾回收器

负责新生代的垃圾回收，通常只支持 1~8 M 的容量。

新生代被分为两个区域：一般是对象区域，一半是空闲区域。新加入的对象都被放入对象区
域，等对象区域快满的时候，会执行一次垃圾清理。

先给对象区域所有垃圾做标记；标记完成后，存活的对象被复制到空闲区域，并且将他们有
序的排列一遍；因为空闲区域里此时是有序的，没有碎片，也就不需要整理了；副垃圾回收
器没有碎片整理。

复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。
这样，就完成了垃圾回收。

因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小
。一旦检测到空间装满了，就执行垃圾回收。

## 垃圾回收工作原理

|          | 目的                                                |
| :------- | :-------------------------------------------------- |
| 分代收集 | 减少每次需遍历的对象，从而减少每次回收的耗时        |
| 增量收集 | 解决了长时间停顿的问题。                            |
| 闲时收集 | 只会在 CPU 空闲尝试运行，以减少可能对代码执行的影响 |

## 分代收集

将堆分为新生代与老生代，多回收新生代，少回收老生代。这样就减少了每次需遍历的对象
，从而减少每次垃圾回收的耗时。
<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-O3ES72-GC-4.png' />

## 增量收集

如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。所以引擎将垃
圾收集工作分成更小的块，每次处理一部分，多次处理。这样就解决了长时间停顿的问题。
<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-tvSGXM-GC-5.png' />

## 闲时收集

垃圾收集器只会在 CPU 空闲时见缝插针式的尝试运行，以减少可能对代码执行的影响。

## 总结

> 什么是垃圾？不再需要，即为垃圾；

全局变量随时可能用到，所以一定不是垃圾。

> 如何捡垃圾（遍历算法）？

标记空间中「可达」值：从根节点（Root）出发，遍历所有的对象；可以遍历到的对象，是
可达的（reachable）；没有被遍历到的对象，不可达的（unreachable）。回收「不可达」
的值所占据的内存,做内存整理。

> 什么时候垃圾回收？

前端有其特殊性，垃圾回收的时候会造成页面卡顿；闲时收集、分代收集、增量收集。

> 浏览器中不同类型变量的内存何时释放？

Javascritp 中类型：值类型，引用类型。引用类型：在没有引用之后，通过 V8 自动回收
。 值类型：如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收；非闭包的情况下
，等待 V8 的新生代切换的时候回收。

> 哪些情况会导致内存泄露？如何避免？

内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起
来。以 Vue 为例，通常有这些情况：监听在 window/body 等事件没有解绑；绑在
EventBus 的事件没有解绑； Vuex 的 $store，watch 了之后没有 unwatch；使用第三方库
创建，没有调用正确的销毁函数。解决办法：beforeDestroy 中及时销毁：

绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener；观察者模式
$on，$off 处理；

如果组件中使用了定时器，应销毁处理；如果在 mounted/created 钩子中使用了第三方库
初始化，对应的销毁；使用弱引用 weakMap、weakSet。

> 闭包会导致内存泄露吗？

正确的答案是不会。内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间
，不能被再次利用起来。闭包里面的变量就是我们需要的变量，不能说是内存泄露。

闭包会导致内存泄露这个误解是如何来的？因为 IE 的 bug，IE 在我们使用完闭包之后，
依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。

> weakMap weakSet 和 Map Set 的区别？

在 ES6 中新增了两个数据结构 WeakMap、WeakSet，就是为了解决内存泄漏的问题。

它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。只要所引
用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。

也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手
动删除引用。

> 弱引用

它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。只要所引
用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。

---

1. [了解浏览器的垃圾回收](https://mp.weixin.qq.com/s/G02qgYGbAxvUeQeQzMBjnA)
