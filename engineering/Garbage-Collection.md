# 浏览器怎么进行垃圾回收？

## 变量的生命周期

```javascript
let dog = {};
dog.a = [];
```

<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-IHbHaF-GC-2.png' width='600px'/>

```javascript
let dog = {};
dog.a = [];
dog.a = {};
```

<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-jLBcSD-GC-1.png' width='600px'/>

a 的指向改变了， 此时堆中的数组对象就成为了不被使用的数据，专业名词叫「不可达」
的数据。这就是需要回收的垃圾数据。

第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对
象就是可以进行垃圾回收的对象。

## 什么时候垃圾回收

浏览器进行垃圾回收的时候，会暂停 JavaScript 脚本，等垃圾回收完毕再继续执行。

对于普通应用这样没什么问题，但对于 JS 游戏、动画对连贯性要求比较高的应用，如果暂
停时间很长就会造成页面卡顿。

垃圾收集器只会在 CPU 空闲时见缝插针式的尝试运行，以减少可能对代码执行的影响。

## 临时对象 VS 长久对象

<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-N3xGwV-GC-3.png' width='600px'/>

浏览器将数据分为两种，一种是「临时」对象，一种是「长久」对象。

| 对象     | 存活的时间 |                                  对象                                  |
| :------- | :--------- | :--------------------------------------------------------------------: |
| 临时对象 | 短         | 函数内部、块级作用域中的变量。执行结束时，作用域中定义的变量就会被销毁 |
| 长久对象 | 长         |                      全局的 window、DOM、Web API                       |

这两种对象对应不同的回收策略，所以，V8 把堆分为新生代和老生代两个区域

| 对象     | V8 堆区分 | 回收器       | 算法                     | 碎片整理 |
| -------- | --------- | ------------ | ------------------------ | -------- |
| 临时对象 | 新生代    | 副垃圾回收器 | 对象、空闲区域，复制对调 | 不需要   |
| 长久对象 | 老生代    | 主垃圾回收器 | 标记-清除                | 需要     |

## 主垃圾回收器

负责老生代的垃圾回收，老生代有两个特点：对象占用空间大；对象存活时间长。  
它使用「标记-清除」的算法执行垃圾回收。

首先是标记。从一组根元素开始，递归遍历这组根元素；在这个遍历过程中，能到达的元素
称为活动对象，没有到达的元素就可以判断为垃圾数据。然后是垃圾清除。

直接将标记为垃圾的数据清理掉。多次标记-清除后，会产生大量不连续的内存碎片，需要
进行内存整理。

## 副垃圾回收器

负责新生代的垃圾回收，通常只支持 1~8 M 的容量。

新生代被分为两个区域：一般是对象区域，一半是空闲区域。新加入的对象都被放入对象区
域，等对象区域快满的时候，会执行一次垃圾清理。

先给对象区域所有垃圾做标记；标记完成后，存活的对象被复制到空闲区域，并且将他们有
序的排列一遍；因为空闲区域里此时是有序的，没有碎片，也就不需要整理了；副垃圾回收
器没有碎片整理。

复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。
这样，就完成了垃圾回收。

因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小
。一旦检测到空间装满了，就执行垃圾回收。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题
，JavaScript 引擎采用了对象晋升策略,也就是经过两次垃圾回收依然还存活的对象，会被
移动到老生区中。

## 垃圾回收工作原理

|          | 目的                                                |
| :------- | :-------------------------------------------------- |
| 分代收集 | 减少每次需遍历的对象，从而减少每次回收的耗时        |
| 增量收集 | 解决了长时间停顿的问题。                            |
| 闲时收集 | 只会在 CPU 空闲尝试运行，以减少可能对代码执行的影响 |

## 分代收集

将堆分为新生代与老生代，多回收新生代，少回收老生代。这样就减少了每次需遍历的对象
，从而减少每次垃圾回收的耗时。
<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-O3ES72-GC-4.png' />

## 增量收集

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的
JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。把这种行为叫做全停顿。

如果执行垃圾回收的过程中，占用主线程时间过久，主线程是不能做其他事情的。比如页面
正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在垃圾回收过
程中无法执行，这将会造成页面的卡顿现象。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时
让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称
为增量标记（Incremental Marking）算法.

使用增量标记算法，可以把`一个完整的垃圾回收任务拆分为很多小的任务`，这些小的任务
执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果
时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。

<image src='https://loremxuetengfei.oss-cn-beijing.aliyuncs.com/20220329-tvSGXM-GC-5.png' />

## 闲时收集

垃圾收集器只会在 CPU 空闲时见缝插针式的尝试运行，以减少可能对代码执行的影响。

## 总结

> 什么是垃圾？不再需要，即为垃圾；

全局变量随时可能用到，所以一定不是垃圾。

> 如何捡垃圾（遍历算法）？

标记空间中「可达」值：从根节点（Root）出发，遍历所有的对象；可以遍历到的对象，是
可达的（reachable）；没有被遍历到的对象，不可达的（unreachable）。回收「不可达」
的值所占据的内存,做内存整理。

> 什么时候垃圾回收？

前端有其特殊性，垃圾回收的时候会造成页面卡顿；闲时收集、分代收集、增量收集。

> 浏览器中不同类型变量的内存何时释放？

Javascritp 中类型：值类型，引用类型。引用类型：在没有引用之后，通过 V8 自动回收
。 值类型：如果处于闭包的情况下，要等闭包没有引用才会被 V8 回收；非闭包的情况下
，等待 V8 的新生代切换的时候回收。

> 哪些情况会导致内存泄露？如何避免？

内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间，不能被再次利用起
来。以 Vue 为例，通常有这些情况：监听在 window/body 等事件没有解绑；绑在
EventBus 的事件没有解绑； Vuex 的 $store，watch 了之后没有 unwatch；使用第三方库
创建，没有调用正确的销毁函数。解决办法：beforeDestroy 中及时销毁：

绑定了 DOM/BOM 对象中的事件 addEventListener ，removeEventListener；观察者模式
$on，$off 处理；

如果组件中使用了定时器，应销毁处理；如果在 mounted/created 钩子中使用了第三方库
初始化，对应的销毁；使用弱引用 weakMap、weakSet。

> 闭包会导致内存泄露吗？

正确的答案是不会。内存泄露是指你「用不到」（访问不到）的变量，依然占居着内存空间
，不能被再次利用起来。闭包里面的变量就是我们需要的变量，不能说是内存泄露。

闭包会导致内存泄露这个误解是如何来的？因为 IE 的 bug，IE 在我们使用完闭包之后，
依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。

闭包的作用域一旦创建，它们有同样的父级作用域，作用域是共享的。

```javascript
{
  const fn = function () {
    let sum = 0;
    return function () {
      sum++;
      console.log(sum);
    };
  };

  fn()(); // 1
  fn()(); // 1
}
{
  const fn = function () {
    let sum = 0;
    return function () {
      sum++;
      console.log(sum);
    };
  };
  fn1 = fn();
  fn1(); //1
  fn1(); //2
  fn1(); //3
  // fn1一直在引用fn()，此时内存就不会被释放，就能实现值的累加。
  fn1 = null; // fn1的引用fn被手动释放了
  fn1 = fn(); // num再次归零
  fn1(); //1
}
```

> weakMap weakSet 和 Map Set 的区别？

在 ES6 中新增了两个数据结构 [WeakMap](javascript/WeakMap.md)、WeakSet，就是为了
解决内存泄漏的问题。

它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。只要所引
用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。

也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手
动删除引用。

> 弱引用

弱引用，就是垃圾回收机制遍历的时候不考虑该引用。只要所引用的对象的其他引用都被清
除，垃圾回收机制就会释放该对象所占用的内存。

> 内存泄漏

不再用到的内存，没有及时释放，就叫做内存泄漏（memory leak）。

---

1. [Fix memory problems - Chrome Developers](https://developer.chrome.com/docs/devtools/memory-problems/)
2. [了解浏览器的垃圾回收](https://mp.weixin.qq.com/s/G02qgYGbAxvUeQeQzMBjnA)
3. [浏览器垃圾回收机制与内存泄漏分析](https://github.com/LuckyWinty/blog/blob/master/markdown/Q%26A/Chrome%20%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%88%86%E6%9E%90.md)
